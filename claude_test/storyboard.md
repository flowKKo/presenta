# 分镜脚本（精简版）：模型只是一半，另一半在脚手架

## 设计约束
1. 每个镜头只承担一个核心信息点，同时可见信息块 <= 3。
2. 字号：标题 56-72px，核心数字 100-140px，正文 30-36px，最小 24px。
3. 不使用 emoji、无意义装饰图形、高频闪烁动画。
4. 保留的可视化类型：数据条、对比卡、PlaceholderBox（截图占位）。
5. 镜头之间用淡入淡出切换，每个镜头内部只做简单的 stagger 入场动画。

---

## 时间结构（与 Remotion 场景对应）

### 幕 1：开场与问题定义（Opening）5 个镜头
- 总时长：5400f

**镜头 1-1：排行榜总览**（1080f）
- 旁白：Terminal-Bench 2.0 有 101 个 Agent。
- 屏幕文字：`Terminal-Bench 2.0` / `101 个 Agent`
- 画面：PlaceholderBox 占据左侧 65% 放排行榜截图，右侧一张信息卡写日期和 Agent 数量，数字 101 用 NumberCounter 大字（140px）。

**镜头 1-2：同模型分差**（1080f）
- 旁白：Opus 4.6 在同榜单上出现 58.0 到 69.9 的明显分差。
- 屏幕文字：`58.0 -> 69.9` / `差 12 分`
- 画面：居中两组大数字（100px），左侧红色 58.0，右侧绿色 69.9，中间箭头。下方一行结论文字。

**镜头 1-3：为什么？脚手架定义**（1080f）
- 旁白：为什么同模型差 12 分？因为脚手架。
- 屏幕文字：`为什么差这么多？` / `脚手架 = 模型的外挂装备`
- 画面：先出现大字问题卡（居中），然后淡入脚手架定义卡（四维度列表：信息输入 / 工具调用 / 结果验证 / 记忆存储）。

**镜头 1-4：Terminus 2 基线**（1080f）
- 旁白：Terminus 2 是最小化脚手架基线，只有 bash 一个工具。
- 屏幕文字：`Terminus 2 = 基线` / `1 个工具: BASH`
- 画面：PlaceholderBox 左侧 65% 放 Terminus 2 截图，右侧两张卡：BASH 工具卡 + 基线意义卡。

**镜头 1-5：脚手架增益数据**（1080f）
- 旁白：GPT-5.3 配合 Terminus 2 得到 64.7，加脚手架到 75.1；Opus 4.6 配合 Terminus 2 得到 62.9，加脚手架到 69.9。5 到 10 个百分点的脚手架增益足以改变排名。
- 屏幕文字：`+10.4` / `+7.0` / `脚手架增益`
- 画面：两组 BarChart 并排（GPT-5.3 / Opus 4.6 各一组），右侧增益 NumberCounter。

---

### 幕 2：六维度 + 信息输入 + 工具设计（DimensionsContextTools）4 个镜头
- 总时长：4800f

**镜头 2-1：六维度总览**（600f）
- 旁白：脚手架可以拆成六个维度来理解。
- 屏幕文字：`脚手架六维度`
- 画面：3x2 网格卡片，每张卡写维度名称和编号，stagger 入场。

**镜头 2-2：信息输入两条路**（1200f）
- 旁白：信息输入有两条主流路线：运行时搜索和语义索引。
- 屏幕文字：`运行时搜索` / `语义索引`
- 画面：SectionHeader（维度1），下方两列对比卡。左列：运行时搜索（Claude Code / Codex CLI），零初始化成本，费 token。右列：语义索引（Augment Code），精准定位，TB2.0 未提交。

**镜头 2-3：工具成功率乘法**（1200f）
- 旁白：工具成功率是乘法，90%/步与 99%/步的最终结果差很大。
- 屏幕文字：`0.9^10 = 34.9%` / `0.99^10 = 90.4%` / `每步 +9% -> 最终 +55%`
- 画面：居中两组公式大字（100px），左侧红色 34.9%，右侧绿色 90.4%，下方一行结论。

**镜头 2-4：工具设计策略对比**（1800f）
- 旁白：Droid 用极简工具，按模型定制格式。Claude Code 用 24 工具 + poka-yoke 防错。两种策略各有取舍。
- 屏幕文字：`Droid: 极简工具` / `Claude: 24 工具 + poka-yoke`
- 画面：左右对比卡，左侧 Droid 极简策略卡（FIND_AND_REPLACE / unified diff），右侧 Claude Code 工具卡。下方一行排名佐证。

---

### 幕 3：提示工程 + 任务分解（DimensionsPromptsPlanning）3 个镜头
- 总时长：4800f

**镜头 3-1：三层提示结构**（1600f）
- 旁白：三层提示结构，关键指令放末端利用 recency bias。Claude Code 也走分层路线。
- 屏幕文字：`工具描述 / 系统提示 / 系统通知` / `recency bias`
- 画面：SectionHeader（维度3），左侧三层堆叠卡（从浅到深蓝色），右侧一条时间轴说明末端优先。

**镜头 3-2：强制规划**（1600f）
- 旁白：强制规划效果好。Junie CLI 必须先生成 requirements.md 和 plan.md 才能开始编码。Droid 把更新后的计划放在上下文末端，配合递近偏差保持方向感。
- 屏幕文字：`req -> plan -> code` / `强制规划`
- 画面：左侧流程卡（三步流程：requirements → plan → code），右侧 Droid 规划 + 递近偏差说明卡。

**镜头 3-3：可选与隐式规划**（1600f）
- 旁白：Claude Code 的 TodoWrite 是可选的，3 步以上自动激活。Codex CLI 和 Gemini CLI 靠模型自身的推理 token 隐式规划。
- 屏幕文字：`可选: TodoWrite` / `隐式: 推理 token`
- 画面：两列对比卡。左列：Claude Code 可选规划（条件触发）。右列：Codex CLI / Gemini CLI 隐式规划。

---

### 幕 4：记忆持久化 + 验证反馈（DimensionsMemoryValidation）4 个镜头
- 总时长：3600f

**镜头 4-1：记忆文件概念**（900f）
- 旁白：主流做法是根目录 .md 记忆文件，每次启动时加载。
- 屏幕文字：`CLAUDE.md / AGENTS.md / GEMINI.md`
- 画面：SectionHeader（维度5），左侧文件树卡（项目根目录 + .md 文件高亮），右侧三个产品记忆文件 pill 标签。

**镜头 4-2：记忆层级对比**（900f）
- 旁白：差异在层级深度，Claude 支持 4 级覆盖，Codex 逐级加载，Gemini 单层。多数框架无状态，每次会话重新读取。
- 屏幕文字：`4 级覆盖` / `逐级加载` / `单层`
- 画面：三列对比卡，每列写产品名 + 层级策略。Claude 列用缩进显示 4 级。

**镜头 4-3：验证流程**（900f）
- 旁白：验证能力决定最终产出质量，Droid 用多补丁方案加测试筛选。
- 屏幕文字：`多补丁 -> 测试选优` / `Patch A / B / C`
- 画面：SectionHeader（维度6），左侧三个补丁卡（A/B/C），B 高亮为通过，右侧一行说明。

**镜头 4-4：验证成本与风险**（900f）
- 旁白：验证会带来 token 成本，平均不到 2M，但峰值可达 13M。agent 自己写 unit test 容易自己考自己，端到端测试更可靠。
- 屏幕文字：`平均 <2M` / `峰值 13M`
- 画面：两行条形图（平均 vs 峰值），下方一行说明假阳性风险。

---

### 幕 5：关键选手上（KeyPlayersTop）2 个镜头
- 总时长：5400f

**镜头 5-1：Simple Codex + Codex CLI**（2700f）
- 旁白：Simple Codex 排名第一，GPT-5.3 + 脚手架，较 Terminus 2 提升 10.4 分。Simple Codex 可能是简化版 Codex CLI。Codex CLI 通过异步模式解耦用户界面和 agent 执行，V4A diff 格式配合 tree-sitter 做 patch 解析。Token 效率突出：7.2 万 vs Claude Code 23.5 万，差 3.3 倍。
- 屏幕文字：`#1 Simple Codex` / `75.1` / `72K vs 235K`
- 画面：左侧产品头（排名 + 名称 + NumberCounter 96px），右侧展示 Codex CLI 架构特性卡（异步解耦 + V4A diff）+ token 效率对比条。

**镜头 5-2：Factory Droid**（2700f）
- 旁白：Droid 排名第三，四个模型全部进前 15，泛化能力最强。核心架构：三层提示 + 工具极简 + 多轨迹生成。社区评价两极分化：benchmark 数据过硬，但实际使用中代码质量问题不少。
- 屏幕文字：`#3 Factory Droid` / `69.9` / `4 模型全进前 15`
- 画面：左侧产品头（排名 + 名称 + NumberCounter 90px），右侧先展示四模型泛化排名，再展示社区评价卡。

---

### 幕 6：关键选手下（KeyPlayersBottom）3 个镜头
- 总时长：4500f

**镜头 6-1：Junie CLI**（1500f）
- 旁白：Junie 排名第八，Gemini 3 Flash 也能打到前十。同模型对比 Junie 64.3 vs Gemini CLI 51.0，脚手架增益 +13.3。强制规划 + AST 解析 + 模型自动切换。
- 屏幕文字：`#8 Junie CLI` / `64.3` / `+13.3`
- 画面：左侧产品头 + BarChart（Junie vs Gemini CLI），右侧增益 NumberCounter（90px）+ 架构特性卡。

**镜头 6-2：Claude Code 负增益**（1500f）
- 旁白：Claude Code 58.0 低于 Terminus 2 基线 62.9。实际体验并不差，反直觉。设计目标是通用编码场景，多工具和 sub-agent 系统在终端任务里复杂度反而帮了倒忙。
- 屏幕文字：`Claude 58.0 < Terminus 62.9` / `通用编码 vs 终端任务`
- 画面：左侧 BarChart（Claude vs Terminus 差值，红色标注低于基线），右侧一张说明卡解释场景错配。

**镜头 6-3：Gemini CLI**（1500f）
- 旁白：Gemini CLI 起步较晚，还在持续优化。亮点是双包分层（CLI + Core 独立复用）和按任务复杂度自动路由模型。其余能力和前面介绍的框架类似。
- 屏幕文字：`Gemini CLI` / `双包分层` / `模型路由`
- 画面：左侧双包架构示意（CLI 层 + Core 层），右侧模型路由卡（Flash / Pro 自动切换）。

---

### 幕 7：Token 效率（TokenEfficiency）1 个镜头
- 总时长：1500f

**镜头 7-1：token 消耗对比**（1500f）
- 旁白：同任务 token 消耗差距明显。Codex CLI 72K，Claude Code 235K，差 3.3 倍。Droid 更夸张，平均不到 200 万，最高 1300 万。Token 效率差异直接影响 API 费用。
- 屏幕文字：`72K vs 235K` / `3.3x` / `Droid: <2M ~ 13M`
- 画面：BarChart 三条（Codex / Claude / Droid），右侧 3.3x 大字 + 一行结论（token 效率 = 费用差异）。

---

### 幕 8：结尾总结（Ending）2 个镜头
- 总时长：3600f

**镜头 8-1：个人经验与 benchmark 局限**（2400f）
- 旁白：Claude Code 是脚手架领域的探索者，sub-agent、Hooks、plugin、skill 这些功能都是率先探索出来的。我日常使用三套组合：Claude Code + Opus 4.6、Codex + GPT-5.3、Droid + Opus 4.6。实际体验中没有哪个工具在所有场景下碾压另一个。Benchmark 排名靠后不代表日常工作里不好用。
- 屏幕文字：`3 套工具组合` / `benchmark =/= 日常体验`
- 画面：左侧三套工具组合卡（每张标注模型 + 脚手架），右侧结论卡（benchmark 衡量的范围有限）。

**镜头 8-2：推荐与收尾**（1200f）
- 旁白：推荐三步深入了解：Terminal-Bench 论文、Codex Agent Loop + Gemini CLI 架构、Anthropic agent 博客。模型只是一半，另一半在脚手架。
- 屏幕文字：`推荐阅读` / `模型只是一半，另一半在脚手架`
- 画面：左侧推荐清单（三步阅读路径），右侧终场大字。

---

## 视觉执行清单
- [ ] 每个镜头同时可见信息块 <= 3
- [ ] 单镜头不混入下一镜头的内容
- [ ] 无 emoji、无无意义装饰
- [ ] 正文字号 >= 28px
- [ ] 关键数字至少 100px
- [ ] 所有卡片不触底，不超出安全边距
